<!DOCTYPE html>


<html>
<head>
<meta charset="UTF-8">
<title>Matrix</title>

<link rel="stylesheet" type="text/css" href="../styles/doc.css"/>
</head>
<body>
<p><a href="mathguide.html">Hauptübersicht</a></p>
<h1>Klasse <code>Matrix</code></h1>
<p> Klasse <code>Matrix</code><br/>
        <i>vgl. Menü: Einfügen -- Matrix</i><br/>
        <b>Matrix(v)</b>: v Liste von gleichlangen Listen,<br/>
        <b>Beispiel</b>:<br/>
        <code>Matrix([[11,12,13],[21,22,23]])</code><br/>
        Die Klasse <code>Matrix</code> ist abgeleitet von <code>Vector</code>:<br/>
        Ein <code>Matrix</code>-Objekt ist ein <code>Vector</code>
        von gleichlangen <code>Vector</code>-Objekten.<br/>
        Die Elemente können mit Doppelindizes (z.B.: <code>A[i,k]</code>) angesprochen werden.
        Indizes werden (wie in Python-Listen etc.) ab 0 gezählt.<br/>
        vgl. Klassenmethoden mit <code>Matrix.</code></p>
<p><b>Basisklasse:</b> <a href="Vector.html"><code>Vector</code></a></p>
<div id="overview"><p style="margin-top:0">Übersicht:</p>
<h2>Konstruktor</h2>
<p><a href="#constr">Matrix</a> (v)</p>
<h2>Klassenmethoden (statische Methoden)</h2>
<table><tr><td><b>Methode</b></td><td><b>Bedeutung</b></td></tr>
<tr><td><a href="#fromFunction">fromFunction</a> (m, n, fn, offset=0)</td><td>Durch Funktion <code>fn</code> berechnete <code>m*n</code>-Matrix</td></tr>
<tr><td><a href="#fromString">fromString</a> (s)</td><td>Matrix aus String</td></tr>
<tr><td><a href="#identity">identity</a> (n)</td><td>n*n-Einheitsmatrix</td></tr>
<tr><td><a href="#null">null</a> (m, n=0)</td><td>m*n-Nullmatrix</td></tr>
<tr><td><a href="#random">random</a> (m,n=0, r=100)</td><td>m*n-Matrix mit Zufallswerten 0..r-1</td></tr>
</table>
<h2>Operatoren</h2>
<table><tr><td><b>Operator</b></td><td><b>Bedeutung</b></td></tr>
<tr><td><a href="#xx20x2bx20y">x + y</a></td><td>Matrix addition operator</td></tr>
<tr><td><a href="#xx5bix5d">x[i]</a></td><td>        Counts from 0
        A[i]   <span style="font-family:Wingdings">à</span> i-th row vector
        A[i,k] <span style="font-family:Wingdings">à</span> element in i-th row, k-th column
    </td></tr>
<tr><td><a href="#x7ex">~x</a></td><td>    </td></tr>
<tr><td><a href="#xx20x2ax20y">x * y</a></td><td>Scalar or matrix multiplication</td></tr>
<tr><td><a href="#x2dx">-x</a></td><td>    </td></tr>
<tr><td><a href="#strx28xx29">str(x)</a></td><td>    </td></tr>
<tr><td><a href="#xx5bix5dx20x3dx20y">x[i] = y</a></td><td>        Counts from 0
        A[i]   <span style="font-family:Wingdings">à</span> i-th row vector
        A[i,k] <span style="font-family:Wingdings">à</span> element in i-th row, k-th column
    </td></tr>
<tr><td><a href="#xx20x2dx20y">x - y</a></td><td>Matrix subtraction operator</td></tr>
</table>
<h2>Objektmethoden</h2>
<table><tr><td><b>Methode</b></td><td><b>Bedeutung</b></td></tr>
<tr><td><a href="#adjoint">adjoint</a> ()</td><td>Adjungierte Matrix</td></tr>
<tr><td><a href="#cofactor">cofactor</a> (i, k)</td><td>Kofaktor zur Zeile i und der Spalte k</td></tr>
<tr><td><a href="#colRange">colRange</a> ()</td><td>Liste aller Spaltenindizes</td></tr>
<tr><td><a href="#complement">complement</a> (i, k)</td><td>Matrix ohne die Zeile i und die Spalte k</td></tr>
<tr><td><a href="#copy">copy</a> ()</td><td>unabhängige Kopie der Matrix A</td></tr>
<tr><td><a href="#det">det</a> ()</td><td>Determinante der Matrix A</td></tr>
<tr><td><a href="#float">float</a> ()</td><td>gibt die Matrix A zurück, in der alle Elemente nach <code>float</code> konvertiert sind</td></tr>
<tr><td><a href="#gaussElim">gaussElim</a> (jordan=True)</td><td>Zeilenstufenform der Matrix A.</td></tr>
<tr><td><a href="#gramSchmidt">gramSchmidt</a> (normalize=False)</td><td>Gram-Schmidt'sches Orthogonalisierungsverfahren.</td></tr>
<tr><td><a href="#height">height</a> ()</td><td>Anzahl der Zeilen der Matrix A</td></tr>
<tr><td><a href="#inverse">inverse</a> ()</td><td>Inverse Matrix A</td></tr>
<tr><td><a href="#isSquare">isSquare</a> ()</td><td>Wahrheitswert (A quadratisch)</td></tr>
<tr><td><a href="#joinBottom">joinBottom</a> (B)</td><td>Vertikale Verkettung von A mit B</td></tr>
<tr><td><a href="#joinRight">joinRight</a> (B)</td><td>Horizontale Verkettung von A mit B</td></tr>
<tr><td><a href="#leastSquares">leastSquares</a> (b)</td><td>Lösung der Normalgleichung</td></tr>
<tr><td><a href="#lup">lup</a> ()</td><td>LRP-Zerlegung (LUP decomposition) der Matrix</td></tr>
<tr><td><a href="#minor">minor</a> (i, k)</td><td>Minor zur Zeile i und der Spalte k</td></tr>
<tr><td><a href="#operators">operators</a> ()</td><td>Nur zur Dokumentation</td></tr>
<tr><td><a href="#rank">rank</a> ()</td><td>Rang der Matrix A</td></tr>
<tr><td><a href="#rowRange">rowRange</a> ()</td><td>Liste aller Zeilenindizes</td></tr>
<tr><td><a href="#solve">solve</a> (b)</td><td>Lösung x des linearen Gleichungssystems Ax = b</td></tr>
<tr><td><a href="#str">str</a> (i,k)</td><td>String-Darstellung des Elements [i,k]</td></tr>
<tr><td><a href="#submatrix">submatrix</a> (i, k, m, n)</td><td>m*n-Untermatrix (Zeilen i..i+m-1, Spalten k..k+n-1)</td></tr>
<tr><td><a href="#transp">transp</a> ()</td><td>berechnet die Transponierte der Matrix A</td></tr>
<tr><td><a href="#width">width</a> ()</td><td>Anzahl der Spalten der Matrix A</td></tr>
</table>
</div><h1>Konstruktor</h1>
<h3><a id="constr">Matrix</a></h3>
<p> Konstruktor</p>
<p><b>Aufruf:</b> <code>Matrix(v)</code></p>
<hr/>
<h1>Klassenmethoden (statische Methoden)</h1>
<h3><a id="fromFunction">fromFunction</a></h3>
<p> <b>Matrix.fromFunction(m,n, fn, offset=0)</b><br/></p>
<p><b>Aufruf:</b> <code>Matrix.fromFunction(m, n, fn, offset=0)</code></p>
<p><b>Beschreibung</b>:<br/>        <i>Durch Funktion <code>fn</code> berechnete <code>m*n</code>-Matrix</i><br/>
        <code>fn</code> muss eine zweistellige Funktion sein.<br/>
        Das allgemeine Element <code>A[i,k]</code> wird mit <code>fn(i+offset,k+offset)</code> berechnet.<br/>
        <b>Beispiel</b>:<br/>
        <code>Matrix.fromFunction(2,4, pow, 1)</code><br/>
        liefert die Matrix<pre>
 / 1 1 1  1 \ 
 |          |
 \ 2 4 8 16 /</pre></p><hr/>
<h3><a id="fromString">fromString</a></h3>
<p> <b>Matrix.fromString(s)</b><br/></p>
<p><b>Aufruf:</b> <code>Matrix.fromString(s)</code></p>
<p><b>Beschreibung</b>:<br/>        <i>Matrix aus String</i><br/>
        Im String s werden die Elemente der Matrix zeilenweise angegeben.<br/>
        Die Zeilen werden durch Semikolon getrennt, die Elemente innerhalb der Zeilen durch Komma.<br/>
        Elemente können auch rational sein (mit Schrägstrich).<br/>
        <b>Beispiel</b>:<br/>
        <code>Matrix.fromString("1, 2, 3.14; 4/5, 5, 6")</code>
        liefert die Matrix<pre>
 / 1    2  3.14 \ 
 |              |
 \ 4/5  5   6   /</pre></p><hr/>
<h3><a id="identity">identity</a></h3>
<p> <b>Matrix.identity(n)</b><br/></p>
<p><b>Aufruf:</b> <code>Matrix.identity(n)</code></p>
<p><b>Beschreibung</b>:<br/>        <i>n*n-Einheitsmatrix</i><br/></p><hr/>
<h3><a id="null">null</a></h3>
<p> <b>Matrix.null(m, n=0)</b><br/></p>
<p><b>Aufruf:</b> <code>Matrix.null(m, n=0)</code></p>
<p><b>Beschreibung</b>:<br/>        <i>m*n-Nullmatrix</i><br/>
        Quadratische Matrix, falls n weggelassen wird.<br/></p><hr/>
<h3><a id="random">random</a></h3>
<p> <b>Matrix.random(m,n=0, r=100)</b><br/></p>
<p><b>Aufruf:</b> <code>Matrix.random(m,n=0, r=100)</code></p>
<p><b>Beschreibung</b>:<br/>        <i>m*n-Matrix mit Zufallswerten 0..r-1</i></p><hr/>
<h1>Operatoren</h1>
<h3><a id="xx20x2bx20y">x + y</a></h3>
<p> <b>A.__add__(B)</b><br/></p>
<p><b>Aufruf:</b> <code>x + y</font></p>
<p><b>Beschreibung</b>:<br/>        <i>Matrix addition operator</i><br/>
        Instead of A = A + B you may write A += B.
    </p><hr/>
<h3><a id="xx5bix5d">x[i]</a></h3>
<p> Definition of the Index operator []</p>
<p><b>Aufruf:</b> <code>x[i]</font></p>
<p><b>Beschreibung</b>:<br/>        Counts from 0
        A[i]   <span style="font-family:Wingdings">à</span> i-th row vector
        A[i,k] <span style="font-family:Wingdings">à</span> element in i-th row, k-th column
    </p><hr/>
<h3><a id="x7ex">~x</a></h3>
<p> Operator ~ (transposition)</p>
<p><b>Aufruf:</b> <code>~x</font></p>
<p><b>Beschreibung</b>:<br/>    </p><hr/>
<h3><a id="xx20x2ax20y">x * y</a></h3>
<p> <b>A.__sub__(B)</b><br/></p>
<p><b>Aufruf:</b> <code>x * y</font></p>
<p><b>Beschreibung</b>:<br/>        <i>Scalar or matrix multiplication</i><br/>
        Instead of A = A * B you may write A *= B.
    </p><hr/>
<h3><a id="x2dx">-x</a></h3>
<p> unary minus operator</p>
<p><b>Aufruf:</b> <code>-x</font></p>
<p><b>Beschreibung</b>:<br/>    </p><hr/>
<h3><a id="strx28xx29">str(x)</a></h3>
<p> Object representation as string</p>
<p><b>Aufruf:</b> <code>str(x)</font></p>
<p><b>Beschreibung</b>:<br/>    </p><hr/>
<h3><a id="xx5bix5dx20x3dx20y">x[i] = y</a></h3>
<p> Definition of the Index operator [] for assignments</p>
<p><b>Aufruf:</b> <code>x[i] = y</font></p>
<p><b>Beschreibung</b>:<br/>        Counts from 0
        A[i]   <span style="font-family:Wingdings">à</span> i-th row vector
        A[i,k] <span style="font-family:Wingdings">à</span> element in i-th row, k-th column
    </p><hr/>
<h3><a id="xx20x2dx20y">x - y</a></h3>
<p> <b>A.__sub__(B)</b><br/></p>
<p><b>Aufruf:</b> <code>x - y</font></p>
<p><b>Beschreibung</b>:<br/>        <i>Matrix subtraction operator</i><br/>
        Instead of A = A - B you may write A -= B.
    </p><hr/>
<h1>Objektmethoden</h1>
<h3><a id="adjoint">adjoint</a></h3>
<p> <b>A.adjoint()</b><br/></p>
<p><b>Aufruf:</b> <code>A.adjoint()</code></p>
<p><b>Beschreibung</b>:<br/>        <i>Adjungierte Matrix</i><br/></p><hr/>
<h3><a id="cofactor">cofactor</a></h3>
<p> <b>A.cofactor(i, k)</b><br/></p>
<p><b>Aufruf:</b> <code>A.cofactor(i, k)</code></p>
<p><b>Beschreibung</b>:<br/>        <i>Kofaktor zur Zeile i und der Spalte k</i><br/>
        (Minor mit Vorzeichen)</p><hr/>
<h3><a id="colRange">colRange</a></h3>
<p> <b>A.rowRange()</b><br/></p>
<p><b>Aufruf:</b> <code>A.colRange()</code></p>
<p><b>Beschreibung</b>:<br/>        <i>Liste aller Spaltenindizes</i></p><hr/>
<h3><a id="complement">complement</a></h3>
<p> <b>A.complement(i, k)</b><br/></p>
<p><b>Aufruf:</b> <code>A.complement(i, k)</code></p>
<p><b>Beschreibung</b>:<br/>        <i>Matrix ohne die Zeile i und die Spalte k</i><br/>
        (Algebraisches Komplement)</p><hr/>
<h3><a id="copy">copy</a></h3>
<p> <b>A.copy()</b><br/></p>
<p><b>Aufruf:</b> <code>A.copy()</code></p>
<p><b>Beschreibung</b>:<br/>        <i>unabhängige Kopie der Matrix A</i></p><hr/>
<h3><a id="det">det</a></h3>
<p> <b>A.det()</b><br/></p>
<p><b>Aufruf:</b> <code>A.det()</code></p>
<p><b>Beschreibung</b>:<br/>        <i>Determinante der Matrix A</i><br/></p><hr/>
<h3><a id="float">float</a></h3>
<p> <b>A.float()</b><br/></p>
<p><b>Aufruf:</b> <code>A.float()</code></p>
<p><b>Beschreibung</b>:<br/>        <i>gibt die Matrix A zurück, in der alle Elemente nach <code>float</code> konvertiert sind</i></p><hr/>
<h3><a id="gaussElim">gaussElim</a></h3>
<p> <b>A.gaussElim(jordan=True)</b><br/></p>
<p><b>Aufruf:</b> <code>self.gaussElim(jordan=True)</code></p>
<p><b>Beschreibung</b>:<br/>        <i>Zeilenstufenform der Matrix A.</i><br/>
        Wenn <var>jordan</var> <code>True</code> ist, wird die reduzierte Zeilenstufenform
        (Gauß-Jordan-Elimination) zurückgegeben, sonst die einfache Zeilenstufenform (Gauß-Elimination).</p><hr/>
<h3><a id="gramSchmidt">gramSchmidt</a></h3>
<p> <b>A.gramSchmidt(normalize=False)</b><br/></p>
<p><b>Aufruf:</b> <code>self.gramSchmidt(normalize=False)</code></p>
<p><b>Beschreibung</b>:<br/>        <i>Gram-Schmidt'sches Orthogonalisierungsverfahren.</i><br/>
        <code>A</code> muss Matrix aus den (linear unabhängigen)
        zu orthogonalisierenden Vektoren (als Zeilen) sein.<br/>
        Wenn <var>normalize</var> True ist, werden die Vektoren normalisiert.<br/>
        Rückgabewert: Matrix mit den orthogonalen Vektoren.<br/>
        <b>Beispiel</b><pre>
 A = Matrix([[1,1],[2,0]])
 A.gramSchmidt()</pre>
        liefert die Matrix<pre>
 / 1   1 \ 
 |       |
 \ 1  -1 /</pre></p><hr/>
<h3><a id="height">height</a></h3>
<p> <b>A.height()</b><br/></p>
<p><b>Aufruf:</b> <code>A.height()</code></p>
<p><b>Beschreibung</b>:<br/>        <i>Anzahl der Zeilen der Matrix A</i></p><hr/>
<h3><a id="inverse">inverse</a></h3>
<p> <b>A.inverse()</b><br/></p>
<p><b>Aufruf:</b> <code>A.inverse()</code></p>
<p><b>Beschreibung</b>:<br/>        <i>Inverse Matrix A</i><br/></p><hr/>
<h3><a id="isSquare">isSquare</a></h3>
<p> <b>A.isSquare()</b><br/></p>
<p><b>Aufruf:</b> <code>A.isSquare()</code></p>
<p><b>Beschreibung</b>:<br/>        <i>Wahrheitswert (A quadratisch)</i></p><hr/>
<h3><a id="joinBottom">joinBottom</a></h3>
<p> <b>A.concat(B)</b><br/></p>
<p><b>Aufruf:</b> <code>A.joinBottom(B)</code></p>
<p><b>Beschreibung</b>:<br/>        <i>Vertikale Verkettung von A mit B</i><br/>
        <b>Voraussetzung</b>: Die beiden Matrizen müssen gleich viele Spalten haben.</p><hr/>
<h3><a id="joinRight">joinRight</a></h3>
<p> <b>A.concat(B)</b><br/></p>
<p><b>Aufruf:</b> <code>A.joinRight(B)</code></p>
<p><b>Beschreibung</b>:<br/>        <i>Horizontale Verkettung von A mit B</i><br/>
        <b>Voraussetzung</b>: Die beiden Matrizen müssen gleich viele Zeilen haben.</p><hr/>
<h3><a id="leastSquares">leastSquares</a></h3>
<p> <b>A.leastSquares(b)</b><br/></p>
<p><b>Aufruf:</b> <code>A.leastSquares(b)</code></p>
<p><b>Beschreibung</b>:<br/>        <i>Lösung der Normalgleichung</i><br/>
        Rückgabewert: <code>(~A*A).solve(~A*b)</code></p><hr/>
<h3><a id="lup">lup</a></h3>
<p> <b>.lup()</b><br/></p>
<p><b>Aufruf:</b> <code>self.lup()</code></p>
<p><b>Beschreibung</b>:<br/>        <i>LRP-Zerlegung (LUP decomposition) der Matrix</i><br/>
        Rückgabewert: Tripel (L, U, P) mit P*A = L*R, wobei:<br/>
        P Permutationsmatrix,<br/>
        L linke (lower) Dreiecksmatrix mit Einsen auf Diagonale,<br/>
        U rechte (upper) Dreiecksmatrix ist.<br/>
        <b>Voraussetzung</b>: Matrix ist invertierbar.</p><hr/>
<h3><a id="minor">minor</a></h3>
<p> <b>A.minor(i, k)</b><br/></p>
<p><b>Aufruf:</b> <code>A.minor(i, k)</code></p>
<p><b>Beschreibung</b>:<br/>        <i>Minor zur Zeile i und der Spalte k</i><br/>
        (Determinante des Algebraischen Komplements)</p><hr/>
<h3><a id="operators">operators</a></h3>
<p> <b>Matrix.operators()</b><br/></p>
<p><b>Aufruf:</b> <code>self.operators()</code></p>
<p><b>Beschreibung</b>:<br/>        <i>Nur zur Dokumentation</i><br/>
        Die Klasse <b>Matrix</b> erlaubt folgende Operatoren:<br/>
        <table>
         <tr><th>Op.</th><th>Funktion</th><th width="30%">Beispiele</th></tr>
         <tr><th>+</th><td>Addition</td><td><code>A + B; A += B</code></td></tr>
         <tr><th>-</th><td>Subtraktion</td><td><code>A - B; A -= B</code></td></tr>
         <tr><th>*</th><td>Matrizenmultiplikation (wenn beide Operanden Matrizen sind) bzw. Skalarmultiplikation (sonst)</td><td><code>a * b; a *= b</code></td></tr>
         <tr><th>-</th><td>unäres Minus</td><td><code>-A</code></td></tr>
         <tr><th>~</th><td>Transponierte Matrix</td><td><code>~A</code></td></tr>
         <tr><th>|</th><td>Verkettung</td><td><code>A | B; A |= B</code></td></tr>
         <tr><th>[ ]</th><td>Indexoperator</td><td><code>A[i,k]</code><br/><code>A[i]</code> (Zeilenvektor)</td></tr>
        </table>
        <font color="#000080" size="-2">Diese Methode dient nur zur Dokumentation. Sie hat keine Wirkung.</font></p><hr/>
<h3><a id="rank">rank</a></h3>
<p> <b>A.rank()</b><br/></p>
<p><b>Aufruf:</b> <code>A.rank()</code></p>
<p><b>Beschreibung</b>:<br/>        <i>Rang der Matrix A</i><br/></p><hr/>
<h3><a id="rowRange">rowRange</a></h3>
<p> <b>A.rowRange()</b><br/></p>
<p><b>Aufruf:</b> <code>A.rowRange()</code></p>
<p><b>Beschreibung</b>:<br/>        <i>Liste aller Zeilenindizes</i></p><hr/>
<h3><a id="solve">solve</a></h3>
<p> <b>A.solve(b)</b><br/></p>
<p><b>Aufruf:</b> <code>A.solve(b)</code></p>
<p><b>Beschreibung</b>:<br/>        <i>Lösung x des linearen Gleichungssystems Ax = b</i><br/>
        b kann Vektor oder Spaltenmatrix sein.</p><hr/>
<h3><a id="str">str</a></h3>
<p> <b>A.str(i,k)</b><br/></p>
<p><b>Aufruf:</b> <code>A.str(i,k)</code></p>
<p><b>Beschreibung</b>:<br/>        <i>String-Darstellung des Elements [i,k]</i></p><hr/>
<h3><a id="submatrix">submatrix</a></h3>
<p> <b>A.submatrix(i, k, m, n)</b><br/></p>
<p><b>Aufruf:</b> <code>A.submatrix(i, k, m, n)</code></p>
<p><b>Beschreibung</b>:<br/>        <i>m*n-Untermatrix (Zeilen i..i+m-1, Spalten k..k+n-1)</i><br/></p><hr/>
<h3><a id="transp">transp</a></h3>
<p> <b>A.transp()</b><br/></p>
<p><b>Aufruf:</b> <code>A.transp()</code></p>
<p><b>Beschreibung</b>:<br/>        <i>berechnet die Transponierte der Matrix A</i><br/>
        kürzer: ~A</p><hr/>
<h3><a id="width">width</a></h3>
<p> <b>A.width()</b><br/></p>
<p><b>Aufruf:</b> <code>A.width()</code></p>
<p><b>Beschreibung</b>:<br/>        <i>Anzahl der Spalten der Matrix A</i></p><hr/>
</body></html>